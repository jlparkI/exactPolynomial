"""Checks the exact polynomial feature generation routines
by comparing their output with a simple, clunky pure-Python
implementation."""
from math import ceil
import sys

import unittest
import numpy as np
from scipy.stats import chi

from cpu_poly_feats import cpuExactQuadratic as CEQ
from cpu_poly_feats import cpuInteractionsOnly as CIO

try:
    from cuda_poly_feats import cudaExactQuadratic as GEQ
    from cuda_poly_feats import cudaInteractionsOnly as GIO
    import cupy as cp
except:
    pass


class TestExactPoly(unittest.TestCase):
    """Tests feature generation for exact polynomial kernels."""

    def test_exact_quadratic(self):
        """Tests the exact quadratic kernel."""
        num_feats = 56
        ndatapoints = 124

        for inter_setting in [True, False]:
            outcomes = run_evaluation(ndatapoints, num_feats,
                    precision = "double", interactions_only = inter_setting)
            for outcome in outcomes:
                self.assertTrue(outcome)

        for inter_setting in [True, False]:
            outcomes = run_evaluation(ndatapoints, num_feats,
                    precision = "float", interactions_only = inter_setting)
            for outcome in outcomes:
                self.assertTrue(outcome)

        num_feats = 128
        ndatapoints = 200
        for inter_setting in [True, False]:
            outcomes = run_evaluation(ndatapoints, num_feats,
                    precision = "double", interactions_only = inter_setting)
            for outcome in outcomes:
                self.assertTrue(outcome)



def run_evaluation(ndatapoints, num_feats, num_threads = 2,
        precision = "double", interactions_only = False):
    """Runs an evaluation using some set of input settings
    (e.g. use CPU or GPU, use X number of frequencies etc."""
    xdata, exact_features, test_array = get_quad_matrices(ndatapoints,
                        num_feats, precision, interactions_only)
    if interactions_only:
        CIO(xdata, test_array, num_threads)
    else:
        CEQ(xdata, test_array, num_threads)

    if precision == "float":
        outcome = np.allclose(exact_features, test_array, rtol=1e-4, atol=1e-4)
    else:
        outcome = np.allclose(exact_features, test_array)
    print(f"Does result match for ndatapoints={ndatapoints}, "
            f"num_aas={num_feats},"
            f" kernel Exact Quadratic, "
            f"interactions only {interactions_only}?\n{outcome}")

    if "cupy" not in sys.modules:
        return [outcome]

    test_array[:] = 0

    xdata = cp.asarray(xdata)
    test_array = cp.asarray(test_array)
    if interactions_only:
        GIO(xdata, test_array, num_threads)
    else:
        GEQ(xdata, test_array, num_threads)

    test_array = cp.asnumpy(test_array)
    if precision == "float":
        outcome_cuda = np.allclose(exact_features, test_array,
                rtol=1e-4, atol=1e-4)
    else:
        outcome_cuda = np.allclose(exact_features, test_array)
    print(f"Does result ON CUDA match for ndatapoints={ndatapoints}, "
            f"num_aas={num_feats},"
            f" kernel Exact Quadratic, "
            f"interactions only {interactions_only}?\n{outcome_cuda}")
    return outcome, outcome_cuda


def get_quad_matrices(ndatapoints, num_feats, precision = "double",
        interactions_only = False):
    """Gets all of the matrices that would ordinarily be generated by
    the exact quad kernel for purposes of running the test."""

    rng = np.random.default_rng(123)
    x_data = rng.uniform(size=(ndatapoints, num_feats))

    if interactions_only:
        num_quad_terms = num_feats + 1 + int((num_feats - 1) * num_feats / 2)
    else:
        num_quad_terms = 2 * num_feats + 1 + int((num_feats - 1) * num_feats / 2)

    exact_features = np.zeros((ndatapoints, num_quad_terms))
    test_array = exact_features.copy()

    out_col = 0
    if precision != "double":
        x_data = x_data.astype(np.float32)

    for i in range(0, num_feats):
        exact_features[:,out_col] = x_data[:,i]
        out_col += 1
        if interactions_only:
            for j in range(i+1, num_feats):
                exact_features[:,out_col] = x_data[:,i] * x_data[:,j]
                out_col += 1
        else:
            for j in range(i, num_feats):
                exact_features[:,out_col] = x_data[:,i] * x_data[:,j]
                out_col += 1
    return x_data, exact_features, test_array


if __name__ == "__main__":
    unittest.main()
